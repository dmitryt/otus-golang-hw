package main

//couldn't find a better way how to include txt file into built program.
var baseTemplate string = `

//Code generated by cool go-validate tool; DO NOT EDIT.
package {{.Package}}
import (
  "errors"
  "fmt"
  "reflect"
  "strconv"
  "strings"
  "regexp"
)
type ValidationError struct {
  Field string
  Err error
}

type _validateValidator func()(error)
func (e ValidationError) Error() string { return fmt.Sprintf("%s: %s;", e.Field, e.Err.Error()) }

var (
  ErrValidationLen = errors.New("Incorrect value length")
  ErrValidationMin = errors.New("Value is less than minimum")
  ErrValidationMax = errors.New("Value is greater than maximum")
  ErrValidationContains = errors.New("Value doesn't contain in provided list")
  ErrValidationRegexp = errors.New("value doesn't match by pattern")
)

func _helperContainsStr(val string, items string) bool {
  arr := strings.Split(items, ",")
  for _, item := range arr {
      if item == val {
          return true
      }
  }
  return false
}

func _helperContainsInt(val int, items string) (bool, error) {
  arr := strings.Split(items, ",")
  for _, item := range arr {
      result, err := strconv.Atoi(item)
      if err != nil {
        return false, err
      }
      if result == val {
          return true, nil
      }
  }
  return false, nil
}

{{range .Models}}
  {{range .Declarations}}
    func (model {{.ModelName}}) {{.Method}}() error {
      rv := reflect.ValueOf(&model)
      //field is not set
      if rv.Elem().FieldByName("{{.Field}}").IsZero() {
        return nil
      }
      {{ $field := (printf "[]%s{model.%s}" .FieldType .Field) }}
      {{if .IsArrayField}}
        {{ $field = (printf "model.%s" .Field) }}
      {{end}}
      for _, value := range {{$field}} {
        {{if (eq .Type "len")}}
          if len(value) != {{.Param}} {
            return ValidationError{Field: "{{.Field}}", Err: ErrValidationLen}
          }
        {{else if (eq .Type "min")}}
          if value < {{.Param}} {
            return ValidationError{Field: "{{.Field}}", Err: ErrValidationMin}
          }
        {{else if (eq .Type "max")}}
          if value > {{.Param}} {
            return ValidationError{Field: "{{.Field}}", Err: ErrValidationMax}
          }
        {{else if (eq .Type "inInt")}}
          result, err := _helperContainsInt(value, "{{.Param}}")
          if err != nil {
            return err
          }
          if !result {
            return ValidationError{Field: "{{.Field}}", Err: ErrValidationContains}
          }
        {{else if (eq .Type "inString")}}
          if !_helperContainsStr(string(value), "{{.Param}}") {
            return ValidationError{Field: "{{.Field}}", Err: ErrValidationContains}
          }
        {{else if (eq .Type "regexp")}}
          re := regexp.MustCompile("{{.Param}}")
          if !re.Match([]byte(value)) {
            return ValidationError{Field: "{{.Field}}", Err: ErrValidationRegexp}
          }
        {{else}}
          return errors.New("Unsupported validation type")
        {{end}}
      }
      return nil
    }
  {{end}}

  {{if .Declarations}}
    func (model {{.Name}}) Validate() ([]ValidationError, error) {
      var vErrors []ValidationError
      validators := []_validateValidator{
        {{range .Declarations}}
          model.{{.Method}},
        {{end}}
      }
      for _, fn := range validators {
        err := fn()
        if err == nil {
          continue
        }
        if vError, ok := err.(ValidationError); ok {
			    vErrors = append(vErrors, vError)
        } else {
          return []ValidationError{}, err
        }
      }
      return vErrors, nil
    }
  {{end}}
{{end}}

`
